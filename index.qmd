---
title: "扩散先验在类超声阴影缺失逆问题中的应用"
author: "马忠慧 (学号：25113060024)"
date: last-modified
format:
  html:
    number-sections: true
    toc: true
    code-tools: true
    theme: cosmo
---

<style>
  /* 1. 全局段落缩进 2 字符，并设置两端对齐 */
  p {
    text-indent: 2em;
    text-align: justify;
  }

  /* 2. 排除不需要缩进的区域 */
  
  /* 提示框 (Callout) 内部通常不缩进，保持对齐更美观 */
  .callout p {
    text-indent: 0;
  }
  
  /* 列表项内部的段落不缩进 */
  li p {
    text-indent: 0;
  }

  /* 交互式图表 (Observable) 产生的文本不缩进，以免破坏 UI 布局 */
  .observablehq p {
    text-indent: 0;
  }
  
  /* 图片和表格的标题不缩进 */
  figure caption, .figure-caption {
    text-indent: 0;
  }
</style>

::: {.callout-note appearance="simple"}
**课程作业信息**

- **学号**：25113060024
- **姓名**：马忠慧
:::

## 数学建模（从正问题到贝叶斯逆问题）

在生物医学图像处理与成像领域中，我们通常将“物理世界到信号的映射”称为正问题，而将“由信号反推物理世界”的过程称为逆问题，将物理世界中真实但不可直接观测的结构记为 $x$，通过成像系统获得的测量信号或图像记为 $y$。二者之间的关系可以用一个最直观的箭头示意来描述：从 $x$ 指向 $y$ 的过程对应正问题，而从 $y$ 指回 $x$ 的过程对应逆问题：

$$
x \xrightarrow{\text{正问题}} y,\qquad
y \xrightarrow{\text{逆问题}} x
$$ {#eq-forward-inverse}

然而，这两个方向并不对称。给定真实世界 $x$ 以及成像系统和物理规律，理论上可以确定性地计算出观测信号 $y$；而反过来，仅凭有限、退化且不可避免地受到噪声污染的观测 $y$，往往存在多个不同的 $x$ 都可以生成同一个 $y$。换言之，正问题通常是确定性的，而逆问题在本质上是不确定的。这种不对称性正是成像逆问题困难性的根源。基于这种不对称性，我们更倾向于用概率语言来表达逆问题中“相信程度”的更新。由于同一个观测 $y$ 可能对应多个可能的物理世界 $x$，逆问题的目标便不再适合被表述为“寻找唯一正确的解”。更合理的提法是：在当前可获得的信息条件下，我对不同候选 $x$ 的相信程度分别有多大？基于此，概率模型被引入，逆问题转变为后验分布 $p(x\mid y)$，即在观测到信号 $y$ 之后，对真实世界 $x$ 的相信程度。贝叶斯公式为这一思想提供了严格而统一的数学表达：

$$
p(x\mid y) \propto p(y\mid x)\,p(x)
$$ {#eq-bayes}

其中，$p(x)$ 是先验分布，用以刻画“物理世界本来应当呈现的合理结构”；$p(y\mid x)$ 是似然函数，用以描述“若真实世界为 $x$，通过正问题生成当前观测 $y$ 的可能性”。后验分布 $p(x\mid y)$ 将这两方面信息整合在一起，既要求解在统计意义上符合对真实世界的先验认识，又要求其能够合理解释实际观测数据。似然函数 $p(y\mid x)$ 的具体形式由正问题中的物理模型及噪声统计共同决定。在真实成像系统中，从 $x$ 到 $y$ 的映射几乎不可能被完全精确地描述，其中总会包含大量无法显式建模的因素，例如微观散射、系统建模误差、电子热散射以及数值离散与近似误差等。科学建模中通常将这些不可精确描述的影响统一归纳为噪声，并通过概率分布来刻画其统计特性。在最基础、也最常见的建模假设下，我们采用加性噪声模型，将正问题写为：

$$
y = A(x) + n,
$$ {#eq-forward-noise}

其中 $A(\cdot)$ 表示正问题算子，例如模糊、遮挡、缺失或下采样等，$n$ 表示噪声项。若进一步假设噪声与信号无关，并服从独立同分布的高斯分布，则有：

$$
n \sim \mathcal{N}(0,\sigma^2 I),
$$ {#eq-gaussian-noise}


* **$n$ (随机向量)**: 这里 $n$ 是一个 $k$ 维列向量，属于实数向量空间 $\\mathbb{R}^k$。在图像处理中，如果图像大小为 $H \\times W$ 且为单通道，则 $k \= H \\cdot W$。  
* **$\\mathcal{N}$ (分布族)**: 代表正态（Normal）或高斯（Gaussian）分布族。  
* **$0$ (均值向量 $\\mu$)**: 这里指的是零向量 $\\mathbf{0} \\in \\mathbb{R}^k$。这意味着噪声是无偏的（Unbiased）。  
  $$\\mathbb{E}\[n\] \= \\mathbf{0}$$  
* **$\\sigma^2 I$ (协方差矩阵 $\\Sigma$)**: 这是理解该噪声性质的核心。$\\Sigma$ 是一个 $k \\times k$ 的矩阵。  
  * **$\\sigma^2$**: 标量，表示噪声的功率或方差。  
  * **$I$**: 单位矩阵，对角线上为 1，其余为 0。

### **1.2 概率密度函数（PDF）的构建**

对于一般的多变量高斯分布 $X \\sim \\mathcal{N}(\\mu, \\Sigma)$，其概率密度函数定义为：

$$f(\\mathbf{x}) \= \\frac{1}{\\sqrt{(2\\pi)^k |\\Sigma|}} \\exp\\left( \-\\frac{1}{2} (\\mathbf{x} \- \\mu)^T \\Sigma^{-1} (\\mathbf{x} \- \\mu) \\right)$$  
针对我们特定的情况 $\\mu \= \\mathbf{0}$ 和 $\\Sigma \= \\sigma^2 I$，我们可以进行如下推导：

1. **行列式计算**: $|\\Sigma| \= (\\sigma^2)^k$。  
2. **逆矩阵计算**: $\\Sigma^{-1} \= \\frac{1}{\\sigma^2} I$。  
3. **指数项简化**:  
   $$(\\mathbf{x} \- \\mu)^T \\Sigma^{-1} (\\mathbf{x} \- \\mu) \= \\frac{1}{\\sigma^2} \\|\\mathbf{x}\\|\_2^2$$

代入得到最终 PDF：

$$f(n) \\propto \\exp\\left( \-\\frac{\\|n\\|^2}{2\\sigma^2} \\right)$$  
**深度洞察**:

* **各向同性（Isotropy）**: 密度函数仅依赖于向量的模长 $\\|n\\|$。这意味着在以原点为中心的超球面上，概率密度是常数。  
* **独立性（Independence）**: 协方差矩阵为对角阵意味着各分量（像素）之间统计独立。

### **1.3 关键性质：旋转不变性 (Rotation Invariance)**

这是 DDRM 算法能够在谱空间工作的基石。

**定理**: 若随机向量 $n \\sim \\mathcal{N}(0, \\sigma^2 I)$，对于任意 $k \\times k$ 的正交矩阵 $Q$（即 $Q^T Q \= I$），变换后的向量 $n' \= Q n$ 依然服从分布 $\\mathcal{N}(0, \\sigma^2 I)$。

证明:

$$Cov(n') \= Q Cov(n) Q^T \= Q (\\sigma^2 I) Q^T \= \\sigma^2 (Q Q^T) \= \\sigma^2 I$$  
**应用**: 这意味着我们可以在任意正交基（例如 SVD 分解中的 $U$ 或 $V$ 矩阵）下分析白噪声，而无需担心改变其分布性质。这解释了为什么 DDRM 可以安全地将图像和噪声投影到谱空间进行处理。

## ---

**2\. 进阶：从欧式距离到马氏距离**

当噪声不再是各向同性的白噪声，而是存在相关性时，距离度量方式发生了本质变化。

### **2.1 为什么会变成马氏距离？**

观察高斯分布指数部分的项：

$$D^2 \= (x \- \\mu)^T \\Sigma^{-1} (x \- \\mu)$$  
这就是 **马氏距离 (Mahalanobis Distance)** 的平方。

#### **情形一：独立白噪声 ($\\Sigma \= I$)**

此时 $\\Sigma^{-1} \= I$，公式退化为：

$$D^2 \= (x \- \\mu)^T (x \- \\mu) \= \\sum (x\_i \- \\mu\_i)^2$$

这正是我们熟悉的 欧式距离。此时数据分布呈正圆球形，物理距离等同于统计距离。

#### **情形二：相关噪声 ($\\Sigma \\neq I$)**

当噪声存在相关性时，数据分布被拉伸为**椭圆**。

* **物理距离误导**: 一个点可能物理距离均值很远，但顺着椭圆的长轴方向，其出现的概率其实很高（统计距离近）。  
* **马氏距离修正**: $\\Sigma^{-1}$ 这一项的作用相当于对空间进行了**旋转和缩放（白化）**，将椭圆校正回正圆。

**结论**: 在存在相关噪声的逆问题中（如 Improved DDPM），最大似然估计（MLE）不再等价于最小化均方误差（MSE/欧式距离），而是等价于最小化马氏距离。

## ---

**3\. 贝叶斯概率理论：从先验到后验**

贝叶斯推断是解决逆问题的核心逻辑框架。对于线性逆问题 $y \= Hx \+ n$：

$$p(x | y) \= \\frac{p(y | x) p(x)}{p(y)}$$

### **3.1 三大核心要素**

1. **先验概率 (Prior) $p(x)$**:  
   * **定义**: 在看到观测 $y$ 之前，我们对 $x$ 的信念（即“自然图像长什么样”）。  
   * **DDRM 应用**: 扩散模型本身就是一个学习到的强先验。$\\nabla\_x \\log p(x)$ (Score Function) 指导图像生成的方向。  
2. **似然函数 (Likelihood) $p(y | x)$**:  
   * **定义**: 假设真实图像是 $x$，观测到 $y$ 的概率。  
   * **公式**: $p(y | x) \\propto \\exp\\left( \-\\frac{\\|y \- Hx\\|^2}{2\\sigma\_y^2} \\right)$。  
   * **作用**: 数据保真项，约束生成结果必须符合观测数据。  
3. **后验概率 (Posterior) $p(x | y)$**:  
   * **定义**: 给定观测 $y$ 后，真实图像 $x$ 的概率分布。  
   * **DDRM 核心**: DDRM 的逆向过程本质上就是从这个后验分布中采样的过程。它利用 SVD 将似然项解耦，并将其与扩散先验结合。

### **3.2 贝叶斯更新的直观理解**

* **先验 (蓝色)**: 我们的预测比较宽泛，不确定性大。  
* **似然 (橙色)**: 观测数据提供了新的位置信息。  
* **后验 (紫色)**: 融合两者后，分布变得**更尖锐**（方差变小），这意味着我们对信号的恢复更有信心了。





其中协方差矩阵 $\sigma^2 I$ 同时隐含了两个重要假设：其一，不同维度（如像素或采样点）之间的噪声相互独立；其二，噪声在所有方向上的强度相同，即各向同性。需要注意的是，独立性与各向同性是两个不同的概念：噪声可以在各维度之间相互独立但呈现各向异性（协方差矩阵为对角但对角元素不全相等），也可以表现出维度间的相关性（协方差矩阵具有非零的非对角元素）。这些假设将直接影响似然函数的几何结构。

```{ojs}
viewof mu = Inputs.range([-5, 5], { value: 0, step: 0.01, label: "μ (mean)" })
viewof sigma = Inputs.range([0.1, 3], { value: 1, step: 0.01, label: "σ (std dev)" })

// 1. 直接在这里显示文本，方差直接在 ${} 里计算，不需要单独定义变量
md`当前参数: μ=${mu.toFixed(2)}, σ=${sigma.toFixed(2)}, σ²=${(sigma * sigma).toFixed(2)}`

// 2. 复杂的计算和绘图逻辑，必须用 { } 包裹起来作为一个整体
{
  const xMin = -4
  const xMax = 4
  
  // 生成数据
  const data = Array.from({ length: 800 }, (_, i) => {
    const x = xMin + (xMax - xMin) * (i / 799)
    const z = (x - mu) / sigma
    const y = Math.exp(-0.5 * z * z) / (sigma * Math.sqrt(2 * Math.PI))
    return { x, y }
  })

  // 绘图
  return Plot.plot({
    width: 720,
    height: 360,
    grid: true,
    x: { label: "x", domain: [xMin, xMax] },
    y: { label: "p(x)", domain: [0, 2] }, // 建议固定Y轴，效果更好
    marks: [
      Plot.line(data, { x: "x", y: "y", strokeWidth: 2 }),
      Plot.ruleY([0])
    ]
  })
}
```
